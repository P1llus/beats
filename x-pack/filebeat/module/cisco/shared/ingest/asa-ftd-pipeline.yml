---
description: "Initial Pipeline for Cisco {< .internal_PREFIX >} logs"
processors:
  #
  # Parse the syslog header
  #
  # This populates the host.hostname, process.name, timestamp and other fields
  # from the header and stores the message contents in log.original.
  - grok:
      field: message
      patterns:
        - "(?:%{SYSLOG_HEADER})?\\s*%{GREEDYDATA:log.original}"
      pattern_definitions:
        SYSLOG_HEADER: "(?:%{SYSLOGFACILITY}\\s*)?(?:%{FTD_DATE:_temp_.raw_date}:?\\s+)?(?:%{PROCESS_HOST}|%{HOST_PROCESS})(?:{DATA})?%{SYSLOG_END}?"
        SYSLOGFACILITY: "<%{NONNEGINT:syslog.facility:int}(?:.%{NONNEGINT:syslog.priority:int})?>"
        # Beginning with version 6.3, Firepower Threat Defense provides the option to enable timestamp as per RFC 5424.
        FTD_DATE: "(?:%{TIMESTAMP_ISO8601}|%{ASA_DATE})"
        ASA_DATE: "(?:%{DAY} )?%{MONTH}  *%{MONTHDAY}(?: %{YEAR})? %{TIME}(?: %{TZ})?"
        PROCESS: "(?:[^%\\s:\\[]+)"
        SYSLOG_END: "(?:(:|\\s)\\s+)"
        # exactly match the syntax for firepower management logs
        PROCESS_HOST: "(?:%{PROCESS:process.name}:\\s%{SYSLOGHOST:host.name})"
        HOST_PROCESS: "(?:%{SYSLOGHOST:host.hostname}:?\\s+)?(?:%{PROCESS:process.name}?(?:\\[%{POSINT:process.pid:long}\\])?)?"

  #
  # Parse FTD/ASA style message
  #
  # This parses the header of an EMBLEM-style message for FTD and ASA prefixes.
  - grok:
      field: log.original
      patterns:
        - "%{FTD_PREFIX}-(?:%{FTD_SUFFIX:_temp_.cisco.suffix}-)?%{NONNEGINT:event.severity:int}-%{POSINT:_temp_.cisco.message_id}?:?\\s*%{GREEDYDATA:message}"
        # Before version 6.3, messages for connection, security intelligence, and intrusion events didn't include an event type ID in the message header.
        - "%{GREEDYDATA:message}"
      pattern_definitions:
        FTD_SUFFIX: "[^0-9-]+"
        # Before version 6.3, FTD used ASA prefix in syslog messages
        FTD_PREFIX: "%{DATA}%(?:[A-Z]+)"

  #
  # Create missing fields when no %FTD label is present
  #
  # message_id is needed in order for some processors below to work.
  - set:
      field: _temp_.cisco.message_id
      value: ""
      if: "ctx?._temp_?.cisco?.message_id == null"

  #
  # set default event.severity to 7 (debug):
  #
  # This value is read from the EMBLEM header and won't be present if this is not
  # an emblem message (firewalls can be configured to report other kinds of events)
  # This has no effect unless var.log_level is above 7 (default) to filter some
  # messages.
  - set:
      field: event.severity
      value: 7
      if: "ctx?.event?.severity == null"

  #
  # Drop messages above configured log_level
  #
  - drop:
      if: "ctx.event.severity > {< .log_level >}"

  #
  # Parse the date included in FTD logs
  #
  - date:
      if: "ctx.event.timezone == null"
      field: "_temp_.raw_date"
      target_field: "@timestamp"
      formats:
        - "ISO8601"
        - "MMM  d HH:mm:ss"
        - "MMM dd HH:mm:ss"
        - "EEE MMM  d HH:mm:ss"
        - "EEE MMM dd HH:mm:ss"
        - "MMM  d HH:mm:ss z"
        - "MMM dd HH:mm:ss z"
        - "EEE MMM  d HH:mm:ss z"
        - "EEE MMM dd HH:mm:ss z"
        - "MMM  d yyyy HH:mm:ss"
        - "MMM dd yyyy HH:mm:ss"
        - "EEE MMM  d yyyy HH:mm:ss"
        - "EEE MMM dd yyyy HH:mm:ss"
        - "MMM  d yyyy HH:mm:ss z"
        - "MMM dd yyyy HH:mm:ss z"
        - "EEE MMM  d yyyy HH:mm:ss z"
        - "EEE MMM dd yyyy HH:mm:ss z"
      on_failure:
        [
          {
            "append":
              {
                "field": "error.message",
                "value": "{{ _ingest.on_failure_message }}",
              },
          },
        ]
  - date:
      if: "ctx.event.timezone != null"
      timezone: "{{ event.timezone }}"
      field: "_temp_.raw_date"
      target_field: "@timestamp"
      formats:
        - "ISO8601"
        - "MMM  d HH:mm:ss"
        - "MMM dd HH:mm:ss"
        - "EEE MMM  d HH:mm:ss"
        - "EEE MMM dd HH:mm:ss"
        - "MMM  d HH:mm:ss z"
        - "MMM dd HH:mm:ss z"
        - "EEE MMM  d HH:mm:ss z"
        - "EEE MMM dd HH:mm:ss z"
        - "MMM  d yyyy HH:mm:ss"
        - "MMM dd yyyy HH:mm:ss"
        - "EEE MMM  d yyyy HH:mm:ss"
        - "EEE MMM dd yyyy HH:mm:ss"
        - "MMM  d yyyy HH:mm:ss z"
        - "MMM dd yyyy HH:mm:ss z"
        - "EEE MMM  d yyyy HH:mm:ss z"
        - "EEE MMM dd yyyy HH:mm:ss z"
      on_failure:
        [
          {
            "append":
              {
                "field": "error.message",
                "value": "{{ _ingest.on_failure_message }}",
              },
          },
        ]

  #
  # Set log.level
  #
  - set:
      field: "log.level"
      if: "ctx.event.severity == 0"
      value: unknown
  - set:
      field: "log.level"
      if: "ctx.event.severity == 1"
      value: alert
  - set:
      field: "log.level"
      if: "ctx.event.severity == 2"
      value: critical
  - set:
      field: "log.level"
      if: "ctx.event.severity == 3"
      value: error
  - set:
      field: "log.level"
      if: "ctx.event.severity == 4"
      value: warning
  - set:
      field: "log.level"
      if: "ctx.event.severity == 5"
      value: notification
  - set:
      field: "log.level"
      if: "ctx.event.severity == 6"
      value: informational
  - set:
      field: "log.level"
      if: "ctx.event.severity == 7"
      value: debug

  - set:
      if: "ctx._temp_.cisco.message_id.startsWith('106')"
      field: event.action
      value: firewall-rule
  - pipeline:
      name: '{< IngestPipeline "100000" >}'
      if: "ctx._temp_.cisco.message_id.startsWith('1')"
      ignore_failure: true
  - pipeline:
      name: '{< IngestPipeline "300000" >}'
      if: "ctx._temp_.cisco.message_id.startsWith('3')"
      ignore_failure: true    
  - pipeline:
      name: '{< IngestPipeline "430000ftd" >}'
      if: "ctx._temp_.cisco.message_id.startsWith('43000')"

  #
  # Remove message.
  #
  # The field has been used as temporary buffer while decoding. The full message
  # is kept log.original. Processors below can still add a message field, as some
  # security events contain an explanatory Message field.
  - remove:
      field:
        - message
      ignore_missing: true
  - script:
      lang: painless
      params:
        "ctx._temp_.cisco.message_id":
          target: event.action
          map:
            "430001": intrusion-detected
            "430002": connection-started
            "430003": connection-finished
            "430004": file-detected
            "430005": malware-detected

        "dns.question.type":
          map:
            "a host address": A
            "ip6 address": AAAA
            "text strings": TXT
            "a domain name pointer": PTR
            "an authoritative name server": NS
            "the canonical name for an alias": CNAME
            "marks the start of a zone of authority": SOA
            "mail exchange": MX
            "server selection": SRV

        "dns.response_code":
          map:
            "non-existent domain": NXDOMAIN
            "server failure": SERVFAIL
            "query refused": REFUSED
            "no error": NOERROR

      source: |
        def getField(Map src, String[] path) {
         for (int i=0; i<path.length-1; i++) {
          src = src.getOrDefault(path[i], null);
          if (src == null || !(src instanceof Map)) {
            return null;
          }
         }
         return src[path[path.length-1]];
        }
        def setField(Map dest, String[] path, def value) {
         for (int i=0; i<path.length-1; i++) {
           dest = dest.computeIfAbsent(path[i], _ -> new HashMap());
         }
         dest[path[path.length-1]] = value;
        }
        for (entry in params.entrySet()) {
          def srcField = entry.getKey();
          def param = entry.getValue();
          String oldVal = getField(ctx, srcField.splitOnToken('.'));
          if (oldVal == null) continue;
          def newVal = param.map?.getOrDefault(oldVal.toLowerCase(), null);
          if (newVal != null) {
            def dstField = param.getOrDefault('target', srcField);
            setField(ctx, dstField.splitOnToken('.'), newVal);
          }
        }

  - set:
      if: "ctx.dns?.question?.type != null && ctx.dns?.response_code == null"
      field: dns.response_code
      value: NOERROR

  #
  # Handle event.duration
  #
  # It can be set from ConnectionDuration FTD field above. This field holds
  # seconds as a string. Copy it to _temp_.duration_hms so that the following
  # processor converts it to the right value and populates start and end.
  - set:
      field: "_temp_.duration_hms"
      value: "{{event.duration}}"
      if: "ctx.event?.duration != null"

  #
  # Process the flow duration "hh:mm:ss" present in some messages
  # This will fill event.start, event.end and event.duration
  #
  - script:
      lang: painless
      if: "ctx?._temp_?.duration_hms != null"
      source: >
        long parse_hms(String s) {
            long cur = 0, total = 0;
            for (char c: s.toCharArray()) {
                if (c >= (char)'0' && c <= (char)'9') {
                    cur = (cur*10) + (long)c - (char)'0';
                } else if (c == (char)':') {
                    total = (total + cur) * 60;
                    cur = 0;
                } else {
                    return 0;
                }
            }
            return total + cur;
        }
        if (ctx?.event == null) {
            ctx['event'] = new HashMap();
        }
        String end = ctx['@timestamp'];
        ctx.event['end'] = end;
        long nanos = parse_hms(ctx._temp_.duration_hms) * 1000000000L;
        ctx.event['duration'] = nanos;
        ctx.event['start'] = ZonedDateTime.ofInstant(
            Instant.parse(end).minusNanos(nanos),
            ZoneOffset.UTC);

  #
  # Normalize protocol names
  #
  - lowercase:
      field: "network.transport"
      ignore_failure: true
      ignore_missing: true
  - lowercase:
      field: "network.protocol"
      ignore_failure: true
      ignore_missing: true
  - lowercase:
      field: "network.application"
      ignore_failure: true
      ignore_missing: true
  - lowercase:
      field: "file.type"
      ignore_failure: true
      ignore_missing: true
  - lowercase:
      field: "network.direction"
      ignore_failure: true
      ignore_missing: true

  #
  # Populate network.iana_number from network.transport. Also does reverse
  # mapping in case network.transport contains the iana_number.
  #
  - script:
      if: "ctx?.network?.transport != null"
      lang: painless
      params:
        icmp: 1
        igmp: 2
        ipv4: 4
        tcp: 6
        egp: 8
        igp: 9
        pup: 12
        udp: 17
        rdp: 27
        irtp: 28
        dccp: 33
        idpr: 35
        ipv6: 41
        ipv6-route: 43
        ipv6-frag: 44
        rsvp: 46
        gre: 47
        esp: 50
        ipv6-icmp: 58
        ipv6-nonxt: 59
        ipv6-opts: 60
      source: >
        def net = ctx.network;
        def iana = params[net.transport];
        if (iana != null) {
          net['iana_number'] = iana;
          return;
        }
        def reverse = new HashMap();
        def[] arr = new def[] { null };
        for (entry in params.entrySet()) {
          arr[0] = entry.getValue();
          reverse.put(String.format("%d", arr), entry.getKey());
        }
        def trans = reverse[net.transport];
        if (trans != null) {
          net['iana_number'] = net.transport;
          net['transport'] = trans;
        }

  #
  # Normalize event.outcome
  #
  - lowercase:
      field: "event.outcome"
      ignore_missing: true
  - set:
      field: "event.outcome"
      if: 'ctx.event?.outcome == "est-allowed"'
      value: allow
  - set:
      field: "event.outcome"
      if: 'ctx.event?.outcome == "permitted"'
      value: allow
  - set:
      field: "event.outcome"
      if: 'ctx.event?.outcome == "denied"'
      value: deny
  - set:
      field: "event.outcome"
      if: 'ctx.event?.outcome == "dropped"'
      value: deny
  - set:
      field: "network.transport"
      if: 'ctx.network?.transport == "icmpv6"'
      value: "ipv6-icmp"

  #
  # Convert integer fields, as output of dissect and kv processors is always a string
  #
  - convert:
      field: "source.port"
      type: integer
      ignore_failure: true
  - convert:
      field: "destination.port"
      type: integer
      ignore_failure: true
  - convert:
      field: "source.bytes"
      type: integer
      ignore_failure: true
  - convert:
      field: "destination.bytes"
      type: integer
      ignore_failure: true
  - convert:
      field: "source.packets"
      type: integer
      ignore_failure: true
  - convert:
      field: "destination.packets"
      type: integer
      ignore_failure: true
  - convert:
      field: "_temp_.cisco.mapped_source_port"
      type: integer
      ignore_failure: true
  - convert:
      field: "_temp_.cisco.mapped_destination_port"
      type: integer
      ignore_failure: true
  - convert:
      field: "_temp_.cisco.icmp_code"
      type: integer
      ignore_failure: true
  - convert:
      field: "_temp_.cisco.icmp_type"
      type: integer
      ignore_failure: true
  - convert:
      field: "network.iana_number"
      type: integer
      ignore_failure: true

  #
  # Assign ECS .ip fields from .address is a valid IP address is found,
  # otherwise set .domain field.
  #
  - grok:
      field: source.address
      patterns:
        - "(?:%{IP:source.ip}|%{GREEDYDATA:source.domain})"
      ignore_failure: true
  - grok:
      field: destination.address
      patterns:
        - "(?:%{IP:destination.ip}|%{GREEDYDATA:destination.domain})"
      ignore_failure: true
  - grok:
      field: client.address
      patterns:
        - "(?:%{IP:client.ip}|%{GREEDYDATA:client.domain})"
      ignore_failure: true
  - grok:
      field: server.address
      patterns:
        - "(?:%{IP:server.ip}|%{GREEDYDATA:server.domain})"
      ignore_failure: true

  #
  # Geolocation for source and destination addresses
  #
  - geoip:
      field: "source.ip"
      target_field: "source.geo"
      ignore_missing: true
  - geoip:
      field: "destination.ip"
      target_field: "destination.geo"
      ignore_missing: true

  #
  # IP Autonomous System (AS) Lookup
  #
  - geoip:
      database_file: GeoLite2-ASN.mmdb
      field: source.ip
      target_field: source.as
      properties:
        - asn
        - organization_name
      ignore_missing: true
  - geoip:
      database_file: GeoLite2-ASN.mmdb
      field: destination.ip
      target_field: destination.as
      properties:
        - asn
        - organization_name
      ignore_missing: true
  - rename:
      field: source.as.asn
      target_field: source.as.number
      ignore_missing: true
  - rename:
      field: source.as.organization_name
      target_field: source.as.organization.name
      ignore_missing: true
  - rename:
      field: destination.as.asn
      target_field: destination.as.number
      ignore_missing: true
  - rename:
      field: destination.as.organization_name
      target_field: destination.as.organization.name
      ignore_missing: true

  #
  # Set mapped_{src|dst}_ip fields only if they consist of a valid IP address.
  #
  - grok:
      field: _temp_.natsrcip
      patterns:
        - "(?:%{IP:_temp_.cisco.mapped_source_ip}|%{GREEDYDATA:_temp_.cisco.mapped_source_host})"
      ignore_failure: true
  - grok:
      field: _temp_.natdstip
      patterns:
        - "(?:%{IP:_temp_.cisco.mapped_destination_ip}|%{GREEDYDATA:_temp_.cisco.mapped_destination_host})"
      ignore_failure: true
  #
  # NAT fields
  #
  # The firewall always populates mapped ip and port even if there was no NAT.
  # This populates both nat.ip and nat.port only when some translation is done.
  # Fills nat.ip and nat.port even when only the ip or port changed.
  - set:
      field: source.nat.ip
      value: "{{_temp_.cisco.mapped_source_ip}}"
      if: "ctx._temp_.cisco.mapped_source_ip != null && (ctx._temp_.cisco.mapped_source_ip != ctx.source.ip || ctx._temp_.cisco.mapped_source_port != ctx.source.port)"
  - set:
      field: source.nat.port
      value: "{{_temp_.cisco.mapped_source_port}}"
      if: "ctx._temp_.cisco.mapped_source_port != null && (ctx._temp_.cisco.mapped_source_ip != ctx.source.ip || ctx._temp_.cisco.mapped_source_port != ctx.source.port)"
  - set:
      field: destination.nat.ip
      value: "{{_temp_.cisco.mapped_destination_ip}}"
      if: "ctx._temp_.cisco.mapped_destination_ip != null && (ctx._temp_.cisco.mapped_destination_ip != ctx.destination.ip || ctx._temp_.cisco.mapped_destination_port != ctx.destination.port)"
  - set:
      field: destination.nat.port
      value: "{{_temp_.cisco.mapped_destination_port}}"
      if: "ctx._temp_.cisco.mapped_destination_port != null && (ctx._temp_.cisco.mapped_destination_ip != ctx.destination.ip || ctx._temp_.cisco.mapped_destination_port != ctx.destination.port)"  

  #
  # Populate ECS event.code
  #
  - convert:
      field: _temp_.cisco.message_id
      target_field: event.code
      type: integer
      ignore_failure: true

  - remove:
      field:
        - _temp_.cisco.message_id
        - event.code
      if: 'ctx._temp_.cisco.message_id == ""'
      ignore_failure: true

  #
  # Copy _temp_.cisco to its final destination, cisco.asa or cisco.ftd.
  #
  - rename:
      field: _temp_.cisco
      target_field: "cisco.{< .internal_prefix >}"
      ignore_failure: true

  #
  # Remove temporary fields
  #
  - remove:
      field: _temp_
      ignore_missing: true

  #
  # Rename some 7.x fields
  #
  - rename:
      field: log.original
      target_field: event.original
      ignore_missing: true
  - rename:
      field: cisco.{< .internal_prefix >}.list_id
      target_field: cisco.{< .internal_prefix >}.rule_name
      ignore_missing: true


  # ECS categorization
  - script:
      lang: painless
      params:
        connection-finished:
          kind: event
          category:
            - network
          type:
            - connection
            - end
        connection-started:
          kind: event
          category:
            - network
          type:
            - connection
            - start
        file-detected:
          kind: alert
          category:
            - malware
          type:
            - info
        firewall-rule:
          kind: event
          category:
            - network
          type:
            - info
        flow-expiration:
          kind: event
          category:
            - network
          type:
            - connection
            - end
        intrusion-detected:
          kind: alert
          category:
            - intrusion_detection
          type:
            - info
        malware-detected:
          kind: alert
          category:
            - malware
          type:
            - info
      source: >-
        if (ctx?.event?.action == null || !params.containsKey(ctx.event.action)) {
          return;
        }
        ctx.event.kind = params.get(ctx.event.action).get('kind');
        ctx.event.category = params.get(ctx.event.action).get('category').clone();
        ctx.event.type = params.get(ctx.event.action).get('type').clone();

        if (ctx?.event?.outcome == null) {
          return;
        }
        if (ctx.event.category.contains('network') || ctx.event.category.contains('intrusion_detection')) {
          if (ctx.event.outcome == 'allow') {
            ctx.event.type.add('allowed');
          }
          if (ctx.event.outcome == 'deny') {
            ctx.event.type.add('denied');
          }
          if (ctx.event.outcome == 'block') {
            ctx.event.type.add('denied');
          }
        }
  - append:
      field: related.ip
      value: "{{source.ip}}"
      if: "ctx?.source?.ip != null"
  - append:
      field: related.ip
      value: "{{destination.ip}}"
      if: "ctx?.destination?.ip != null"
  - append:
      field: related.user
      value: "{{user.name}}"
      if: "ctx?.user?.name != null"
  - append:
      field: related.hash
      value: "{{file.hash.sha256}}"
      if: "ctx?.file?.hash?.sha256 != null"


on_failure:
  # Copy any fields under _temp_.cisco to its final destination. Those can help
  # with diagnosing the failure.
  - rename:
      field: _temp_.cisco
      target_field: "cisco.{< .internal_prefix >}"
      ignore_failure: true
  # Remove _temp_ to avoid adding a lot of unnecessary fields to the index.
  - remove:
      field: _temp_
      ignore_missing: true
  - append:
      field: "error.message"
      value: "{{ _ingest.on_failure_message }}"
